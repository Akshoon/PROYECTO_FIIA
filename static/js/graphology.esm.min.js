// Simplified version of Graphology for basic functionality
// This is a minimal implementation to get the app working

class Graph {
  constructor(options = {}) {
    this._nodes = new Map();
    this._edges = new Map();
    this._nodeAttributes = new Map();
    this._edgeAttributes = new Map();
    this._inEdges = new Map();
    this._outEdges = new Map();
    this._multi = options.multi || false; // Support multi-graph option
  }

  // Node methods
  addNode(key, attributes = {}) {
    if (this._nodes.has(key)) {
      throw new Error('Node already exists: ' + key);
    }
    this._nodes.set(key, true);
    this._nodeAttributes.set(key, { ...attributes });
    this._inEdges.set(key, new Set());
    this._outEdges.set(key, new Set());
    return key;
  }

  hasNode(key) {
    return this._nodes.has(key);
  }

  dropNode(key) {
    if (!this._nodes.has(key)) {
      throw new Error('Node does not exist: ' + key);
    }
    // Remove all connected edges
    const edgesToRemove = [
      ...this._inEdges.get(key),
      ...this._outEdges.get(key)
    ];
    for (const edgeKey of edgesToRemove) {
      this.dropEdge(edgeKey);
    }
    this._nodes.delete(key);
    this._nodeAttributes.delete(key);
    this._inEdges.delete(key);
    this._outEdges.delete(key);
  }

  getNodeAttributes(key) {
    if (!this._nodes.has(key)) {
      throw new Error('Node does not exist: ' + key);
    }
    return this._nodeAttributes.get(key) || {};
  }

  getNodeAttribute(key, attr) {
    const attrs = this.getNodeAttributes(key);
    return attrs[attr];
  }

  setNodeAttribute(key, attr, value) {
    if (!this._nodes.has(key)) {
      throw new Error('Node does not exist: ' + key);
    }
    const attrs = this._nodeAttributes.get(key) || {};
    attrs[attr] = value;
    this._nodeAttributes.set(key, attrs);
  }

  updateNodeAttributes(key, updater) {
    if (!this._nodes.has(key)) {
      throw new Error('Node does not exist: ' + key);
    }
    const attrs = this._nodeAttributes.get(key) || {};
    const newAttrs = updater(attrs);
    this._nodeAttributes.set(key, newAttrs);
  }

  mergeNodeAttributes(key, newAttrs) {
    if (!this._nodes.has(key)) {
      throw new Error('Node does not exist: ' + key);
    }
    const attrs = this._nodeAttributes.get(key) || {};
    this._nodeAttributes.set(key, { ...attrs, ...newAttrs });
  }

  // Edge methods
  addEdge(source, target, attributes = {}) {
    if (!this._nodes.has(source)) {
      throw new Error('Source node does not exist: ' + source);
    }
    if (!this._nodes.has(target)) {
      throw new Error('Target node does not exist: ' + target);
    }

    // Generate unique edge key
    let edgeKey = `${source}->${target}`;
    if (this._multi) {
      let counter = 0;
      while (this._edges.has(edgeKey + (counter > 0 ? `_${counter}` : ''))) {
        counter++;
      }
      edgeKey = edgeKey + (counter > 0 ? `_${counter}` : '');
    } else if (this._edges.has(edgeKey)) {
      throw new Error('Edge already exists: ' + edgeKey);
    }

    this._edges.set(edgeKey, { source, target });
    this._edgeAttributes.set(edgeKey, { ...attributes });
    this._outEdges.get(source).add(edgeKey);
    this._inEdges.get(target).add(edgeKey);
    return edgeKey;
  }

  hasEdge(source, target) {
    const edgeKey = `${source}->${target}`;
    if (this._edges.has(edgeKey)) return true;
    // Check for multi-graph edges
    for (const key of this._edges.keys()) {
      if (key.startsWith(edgeKey)) return true;
    }
    return false;
  }

  dropEdge(edgeKey) {
    const edge = this._edges.get(edgeKey);
    if (!edge) {
      throw new Error('Edge does not exist: ' + edgeKey);
    }
    this._outEdges.get(edge.source).delete(edgeKey);
    this._inEdges.get(edge.target).delete(edgeKey);
    this._edges.delete(edgeKey);
    this._edgeAttributes.delete(edgeKey);
  }

  getEdgeAttributes(edgeKey) {
    if (!this._edges.has(edgeKey)) {
      throw new Error('Edge does not exist: ' + edgeKey);
    }
    return this._edgeAttributes.get(edgeKey) || {};
  }

  getEdgeAttribute(edgeKey, attr) {
    const attrs = this.getEdgeAttributes(edgeKey);
    return attrs[attr];
  }

  setEdgeAttribute(edgeKey, attr, value) {
    if (!this._edges.has(edgeKey)) {
      throw new Error('Edge does not exist: ' + edgeKey);
    }
    const attrs = this._edgeAttributes.get(edgeKey) || {};
    attrs[attr] = value;
    this._edgeAttributes.set(edgeKey, attrs);
  }

  updateEdgeAttributes(edgeKey, updater) {
    if (!this._edges.has(edgeKey)) {
      throw new Error('Edge does not exist: ' + edgeKey);
    }
    const attrs = this._edgeAttributes.get(edgeKey) || {};
    const newAttrs = updater(attrs);
    this._edgeAttributes.set(edgeKey, newAttrs);
  }

  // Edge source/target
  source(edgeKey) {
    const edge = this._edges.get(edgeKey);
    if (!edge) {
      throw new Error('Edge does not exist: ' + edgeKey);
    }
    return edge.source;
  }

  target(edgeKey) {
    const edge = this._edges.get(edgeKey);
    if (!edge) {
      throw new Error('Edge does not exist: ' + edgeKey);
    }
    return edge.target;
  }

  extremities(edgeKey) {
    const edge = this._edges.get(edgeKey);
    if (!edge) {
      throw new Error('Edge does not exist: ' + edgeKey);
    }
    return [edge.source, edge.target];
  }

  // Degree methods
  degree(key) {
    if (!this._nodes.has(key)) {
      throw new Error('Node does not exist: ' + key);
    }
    return this._inEdges.get(key).size + this._outEdges.get(key).size;
  }

  inDegree(key) {
    if (!this._nodes.has(key)) {
      throw new Error('Node does not exist: ' + key);
    }
    return this._inEdges.get(key).size;
  }

  outDegree(key) {
    if (!this._nodes.has(key)) {
      throw new Error('Node does not exist: ' + key);
    }
    return this._outEdges.get(key).size;
  }

  // Iteration methods
  forEachNode(callback) {
    for (const key of this._nodes.keys()) {
      callback(key, this._nodeAttributes.get(key));
    }
  }

  forEachEdge(callback) {
    for (const [key, edge] of this._edges.entries()) {
      callback(key, this._edgeAttributes.get(key), edge.source, edge.target);
    }
  }

  forEachNeighbor(nodeKey, callback) {
    if (!this._nodes.has(nodeKey)) {
      throw new Error('Node does not exist: ' + nodeKey);
    }
    const neighbors = new Set();
    for (const edgeKey of this._outEdges.get(nodeKey)) {
      neighbors.add(this._edges.get(edgeKey).target);
    }
    for (const edgeKey of this._inEdges.get(nodeKey)) {
      neighbors.add(this._edges.get(edgeKey).source);
    }
    for (const neighbor of neighbors) {
      callback(neighbor, this._nodeAttributes.get(neighbor));
    }
  }

  // Get arrays
  nodes() {
    return Array.from(this._nodes.keys());
  }

  edges() {
    return Array.from(this._edges.keys());
  }

  neighbors(nodeKey) {
    if (!this._nodes.has(nodeKey)) {
      throw new Error('Node does not exist: ' + nodeKey);
    }
    const neighbors = new Set();
    for (const edgeKey of this._outEdges.get(nodeKey)) {
      neighbors.add(this._edges.get(edgeKey).target);
    }
    for (const edgeKey of this._inEdges.get(nodeKey)) {
      neighbors.add(this._edges.get(edgeKey).source);
    }
    return Array.from(neighbors);
  }

  // Count methods
  get order() {
    return this._nodes.size;
  }

  get size() {
    return this._edges.size;
  }

  // Utility methods
  clear() {
    this._nodes.clear();
    this._edges.clear();
    this._nodeAttributes.clear();
    this._edgeAttributes.clear();
    this._inEdges.clear();
    this._outEdges.clear();
  }

  copy() {
    const newGraph = new Graph({ multi: this._multi });
    for (const [key, attrs] of this._nodeAttributes.entries()) {
      newGraph.addNode(key, { ...attrs });
    }
    for (const [edgeKey, edge] of this._edges.entries()) {
      const attrs = this._edgeAttributes.get(edgeKey);
      newGraph._edges.set(edgeKey, { ...edge });
      newGraph._edgeAttributes.set(edgeKey, { ...attrs });
      newGraph._outEdges.get(edge.source).add(edgeKey);
      newGraph._inEdges.get(edge.target).add(edgeKey);
    }
    return newGraph;
  }

  // Export to plain object (useful for serialization)
  export() {
    const nodes = [];
    const edges = [];
    
    this.forEachNode((key, attrs) => {
      nodes.push({ key, attributes: { ...attrs } });
    });
    
    this.forEachEdge((key, attrs, source, target) => {
      edges.push({ key, source, target, attributes: { ...attrs } });
    });
    
    return { nodes, edges };
  }

  // Import from plain object
  import(data) {
    this.clear();
    for (const node of data.nodes || []) {
      this.addNode(node.key, node.attributes);
    }
    for (const edge of data.edges || []) {
      this._edges.set(edge.key, { source: edge.source, target: edge.target });
      this._edgeAttributes.set(edge.key, edge.attributes || {});
      this._outEdges.get(edge.source).add(edge.key);
      this._inEdges.get(edge.target).add(edge.key);
    }
  }
}

// Export for different module systems
if (typeof module !== 'undefined' && module.exports) {
  module.exports = { Graph };
} else if (typeof window !== 'undefined') {
  window.graphology = { Graph };
}

export { Graph };
export default Graph;